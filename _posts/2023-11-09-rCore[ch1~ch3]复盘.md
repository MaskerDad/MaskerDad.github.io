---
title: rCore[ch1~ch3]复盘

date: 2023-11-09 17:00:00 +0800

categories: [读书笔记, rCore指导文档]

tags: [rCore]

description: 
---



# 前言

本文对rCore文档做一个复盘，尽管rCore的设计十分精简，但其中有很多值得琢磨的细节。

参考文档如下：

[rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)](https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html)

[Introduction - 《rCore 手册（rCore tutorial doc）》 - 书栈网 · BookStack](https://www.bookstack.cn/read/rCore_tutorial_doc/4545d357008f7548.md)

[Archive - 一只豆腐 (hangx-ma.github.io)](https://hangx-ma.github.io/blog/archive.html?tag=rCore)

# 一 应用程序与基本执行环境

## 1 概述

让应用与硬件隔离，简化了应用访问硬件的难度和复杂性。这也是**远古操作系统雏形**和现代的一些简单嵌入式操作系统的主要功能。具有这样功能的操作系统形态就是一个**函数库，**可以被应用访问，并通过函数库的函数来访问硬件。

我们将本章所实现的操作系统称为  `LibOS`，整体架构如下图：

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241628179.png" style="zoom: 25%;" />

通过上图，大致流程如下：

1. 首先，Qemu把包含 `app` 和 `LibOS` 的image镜像加载到内存中；
2. `RustSBI(bootloader)` 完成基本的硬件初始化后，跳转到`LibOS` 起始位置；
3. `LibOS` 首先进行 `app` 执行前的初始化工作，即建立栈空间和清零bss段，然后跳转到 `app` 去执行；
4. `app` 在执行过程中，会通过函数调用的方式得到 `LibOS` 提供的OS服务，如输出字符串等，避免了 `app` 与硬件直接交互的繁琐过程。

## 2 重点内容梳理

本章所讨论的重点内容如下：

* rCore的开发环境
* rCore接入qemu riscv virt平台
* 为rCore支持函数调用
* 关于RustSBI/OpenSBI所提供的服务

---

```rust
pub fn rust_main() -> ! {
	//...
    clear_bss();
    println!("[kernel] Hello, world!");
    sbi::shutdown(false)
}
```

### 2.1 rCore的开发环境

内核层面的开发和我们平时常接触的应用程序开发是有很大区别的，无论环境平台还是知识背景。对于应用程序开发而言，操作系统和函数库已经为我们屏蔽了底层硬件的差异性和复杂性，同时还为程序的运行做了大量的初始化准备工作，这让我们充分享受到了程序开发的便捷性，只关注于程序的功能与性能即可；但内核开发，尤其是我们要写一个操作系统 `rCore`，那么一夜回到解放前，传统应用程序开发所依赖的操作系统 `linux/windows` 被移除了，我们不再能使用这些OS提供的各种服务，同时和 `linux/windows` 系统深度绑定的库函数也无法使用了。

上面的描述中，就好像rCore的开发环境一下子退化到了 ”石器时代“，其实还没有那么糟糕，我们所拥有的有很多，包括工具和平台：

`toolchain`

* 用Rust写代码，至少我们有一个 `rustc` 编译器，如果在x86/ARM主机上就属于交叉编译，需要配置一下编译工具链和编译器目标平台；
* Rust提供了一些库函数，这些函数和任何系统无关，它们被称为 `core`，我们可以放心的使用；

`paltform`

* 我们一般在x86主机上去写rCore，但需要一个测试环境去运行rCore，也就是必须搭建一个riscv机器。
  * 虚拟平台：`qemu-riscv-virt`
  * 物理平台：`k210`
* 从系统级软件层次上看，操作系统并不是最底层的，OS之下还有固件、bootloader。固件一般是厂商内置在ROM中的，我们一般不关心它；bootloader用于引导并加载操作系统，在RISC-V架构中bootloader是运行在M-mode下的程序，遵循SBI规范，为上层操作系统提供服务。目前最为流行的开源的SBI实现为 `OpenSBI`，我们这里使用更加精简的 `RustSBI`，也就是说rCore完全不是从零开始，它可以直接调用SBI提供的服务。

以上rCore环境搭建的问题，重点内容总结如下，具体看指导书。

---

#### 编译器配置

* rustc 编译器目标平台：`riscv64gc-unknown-none-elf`

  ```shell
  rustup target add riscv64gc-unknown-none-elf
  
  # os/.cargo/config
  [build]
  target = "riscv64gc-unknown-none-elf"
  ```

* 移除标准库依赖

  * 移除std，使用core，在 `main.rs` 的开头加上一行 `#![no_std]`；

  * 提供panic_handler以应对致命错误：

    ```rust
    // os/src/lang_items.rs
    use core::panic::PanicInfo;
    
    #[panic_handler]
    fn panic(_info: &PanicInfo) -> ! {
        loop {}
    }
    ```

  * 移除 `main` 函数

    编译器提醒我们缺少一个名为 `start` 的语义项。我们回忆一下，之前提到语言标准库和三方库作为应用程序的执行环境，需要负责在执行应用程序之前进行一些初始化工作，然后才跳转到应用程序的入口点（也就是跳转到我们编写的 `main` 函数）开始执行。事实上 `start` 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。

    我们在 `main.rs` 的开头加入设置 `#![no_main]` 告诉编译器我们没有一般意义上的 `main` 函数，并将原来的 `main` 函数删除。在失去了 `main` 函数的情况下，编译器也就不需要完成所谓的初始化工作了。

---

#### 关于qemu virt平台

我们使用软件 `qemu-system-riscv64` 来模拟一台 64 位 RISC-V 架构的计算机，它包含CPU 、物理内存以及若干 I/O 外设。使用如下命令来启动 Qemu 并运行我们的内核：

```shell
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
```

关于qemu virt平台的细节：[QEMU RISC-V virt 平台分析 - 掘金 (juejin.cn)](https://juejin.cn/post/6891922292075397127)

### 2.2 rCore接入qemu virt平台

[内核第一条指令（基础篇） - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html#)

指导书中很详细，这里总结一下：

* **关于qemu的启动流程**
  * 第一阶段：从 `PC=0x1000` 处开始执行内置固件，然后跳转至 `0x80000000`；
  * 第二阶段：将bootloader.bin放置于 `0x80000000` 处，再跳转至 `0x80200000`；
  * 第三阶段：将os.bin的第一条指令放置于 `0x80200000` 处（需要我们手动调整）；
* **程序内存布局与编译流程**
  * 内存布局：
    * 已初始化的全局数据段 `.rodata/.data`；
    * 未初始化的全局数据段 `.bss`；
    * 栈 `.stack`；
    * 堆 `.heap`；
  * 编译流程
    * 经过预编译、编译、汇编后，对于每一个源文件，会形成相应的目标文件，这个过程我们无需调整；
    * 链接：将所有输入的目标文件整合成一个整体的内存布局。这个过程中，我们可以编写链接脚本，让链接器按照我们自定义的规则进行链接。

---

> 实现rCore与qemu正确对接需要怎么做？

1. 首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 `0x80200000` 处，同时代码段所在的地址应低于其他段；

   ```rust
   # os/src/entry.asm
        .section .text.entry
        .globl _start
    _start:
        li x1, 100
   
   # os/src/linker.ld
   OUTPUT_ARCH(riscv)
   ENTRY(_start)
   BASE_ADDRESS = 0x80200000;
   
   SECTIONS
   {
       . = BASE_ADDRESS;
       skernel = .;
   
       stext = .;
       .text : {
           *(.text.entry)
           *(.text .text.*)
       }
       //...
   }
   ```

2. 其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此我们必须去除掉一些额外的 `ELF_Header` 信息。

   ```shell
   rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin
   ```

### 2.3 为rCore支持函数调用

[为内核支持函数调用 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html)

#### 实现嵌套函数调用的控制流

在实际编写代码的时候我们常常会遇到函数 **多层嵌套调用** 的情形。我们很容易想象，如果函数不支持嵌套调用，那么编程将会变得多么复杂。如果我们试图在一个函数中调用一个子函数，在跳转到子函数的同时，`ra` 会被覆盖成这条跳转指令的下一条的地址，而 `ra` 之前所保存的函数的返回地址将会 永久丢失 。

因此，若想正确实现嵌套函数调用的控制流，我们必须通过某种方式保证：在一个函数调用子函数的前后，`ra` 寄存器的值不能发生变化。但实际上，这并不仅仅局限于 `ra` 一个寄存器，而是作用于所有的通用寄存器。这是因为，编译器是独立编译每个函数的，因此一个函数并不能知道它所调用的子函数修改了哪些寄存器。而站在一个函数的视角，在调用子函数的过程中某些寄存器的值被覆盖的确会对它接下来的执行产生影响。因此这是必要的。我们将由于函数调用，在控制流转移前后需要保持不变的寄存器集合称之为 **函数调用上下文** (Function Call Context) 。

由于每个 CPU 只有一套寄存器，我们若想在子函数调用前后保持函数调用上下文不变，就**需要物理内存的帮助。**确切的说，在调用子函数之前，我们需要在物理内存中的一个区域 **保存** (Save) 函数调用上下文中的寄存器；而在函数执行完毕后，我们会从内存中同样的区域读取并 **恢复** (Restore) 函数调用上下文中的寄存器。实际上，这一工作是由子函数的调用者和被调用者（也就是子函数自身）合作完成。函数调用上下文中的寄存器被分为如下两类：

- **被调用者保存(Callee-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要被调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变；
- **调用者保存(Caller-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要发起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变。

我们发现无论是调用函数还是被调用函数，都会因调用行为而需要两段匹配的保存和恢复寄存器的汇编代码，可以分别将其称为 **开场** (Prologue) 和 **结尾** (Epilogue)，它们会由编译器帮我们自动插入，来完成相关寄存器的保存与恢复。一个函数既有可能作为调用者调用其他函数，也有可能作为被调用者被其他函数调用。

#### RISC-V函数调用规范

RISC-V 架构上的 C 语言调用规范对通用寄存器的使用做出了如下约定：

| 寄存器组                  | 保存者       | 功能                                                     |
| ------------------------- | ------------ | -------------------------------------------------------- |
| a0~a7（ `x10~x17` ）      | 调用者保存   | 用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。     |
| t0~t6( `x5~x7,x28~x31` )  | 调用者保存   | 作为临时寄存器使用，在被调函数中可以随意使用无需保存。   |
| s0~s11( `x8~x9,x18~x27` ) | 被调用者保存 | 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 |

剩下的 5 个通用寄存器情况如下：

- zero( `x0` ) ：它恒为零，函数调用不会对它产生影响；
- ra( `x1` ) ：是被调用者保存的。被调用者函数可能也会调用函数，在调用之前就需要修改 `ra` 使得这次调用能正确返回。因此，每个函数都需要在开头保存 `ra` 到自己的栈帧中，并在结尾使用 `ret` 返回之前将其恢复。
- sp( `x2` ) ：是被调用者保存的，栈指针 (Stack Pointer) 寄存器，它指向下一个将要被存储的栈顶位置。
- fp( `s0` )：它既可作为 `s0` 临时寄存器，也可作为栈帧指针（Frame Pointer）寄存器，表示当前栈帧的起始位置，是一个被调用者保存寄存器。`fp` 指向的栈帧起始位置和 `sp` 指向的栈帧的当前栈顶位置形成了所对应函数栈帧的空间范围。
- gp( `x3` ) 和 tp( `x4` )：在一个程序运行期间都不会变化，因此不必放在函数调用上下文中。

> 栈帧（stack frame）就是一个函数所使用的栈的一部分区域，所有函数的栈帧串起来就组成了一个完整的函数调用栈。一般而言，当前执行函数的栈帧的两个边界分别由栈指针 (Stack Pointer)寄存器和栈帧指针（frame pointer）寄存器来限定。

#### 分配并使用启动栈

使用 `rust-objdump` 工具反汇编内核或者应用程序可执行文件，并找到某个函数的入口。然后，我们能够看到在函数的开场和结尾阶段，编译器会生成类似的汇编代码：

```assembly
# 开场
# 为当前函数分配 64 字节的栈帧
addi        sp, sp, -64
# 将 ra 和 fp 压栈保存
sd  ra, 56(sp)
sd  s0, 48(sp)
# 更新 fp 为当前函数栈帧顶端地址
addi        s0, sp, 64

# 函数执行
# 中间如果再调用了其他函数会修改 ra

# 结尾
# 恢复 ra 和 fp
ld  ra, 56(sp)
ld  s0, 48(sp)
# 退栈
addi        sp, sp, 64
# 返回，使用 ret 指令或其他等价的实现方式
ret
```

从上面我们可以看出一些问题，函数调用上下文所涉及的这些寄存器中，只有 `sp` 寄存器需要进行初始化设置，也就是为函数调用栈准备一个起始地址即可，后续编译过程中插入的 ”开场/结尾“ 代码段会完成所有的函数调用上下文保存恢复工作。

> 你没听错，只需要初始化 `sp` 即可，甚至 `fp` 都不需要设置初值，因为 `fp` 指向最初的 `sp`，两者是相同的。

我们在 `entry.asm` 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 `sp` 设置为栈顶的位置。

```assembly
# os/src/entry.asm
    .section .text.entry
    .globl _start
_start:
    la sp, boot_stack_top
    call rust_main

    .section .bss.stack
    .globl boot_stack_lower_bound
boot_stack_lower_bound:
    .space 4096 * 16
    .globl boot_stack_top
boot_stack_top:

# linker.ld
.bss : {
    *(.bss.stack)
    sbss = .;
    *(.bss .bss.*)
    *(.sbss .sbss.*)
}
ebss = .;

# os/src/main.rs
#[no_mangle]
pub fn rust_main() -> ! {
    loop {}
}
```

有一些**需要特别注意的点：**

* 将 `rust_main` 标记为 `#[no_mangle]`

  `#[no_mangle]` 用于告诉 Rust 编译器：不要乱改函数的名称。 Mangling 的定义是：当 Rust 因为编译需要去修改函数的名称，例如为了让名称包含更多的信息，这样其它的编译部分就能从该名称获取相应的信息，这种修改会导致函数名变得相当不可读。因此，为了防止在链接的时候， entry.asm 找不到 main.rs 提供的外部符号 rust_main 从而导致链接失败，我们必须要禁止掉该功能。

* 为何将栈空间放置在 `.bss.stack` 中？

  将stack放置到bss附近（bss之前，之后，之中），生成的ELF文件这部分没有实际存储。如果放置到data之前，之中，stack后面有0之外的数据，会实际存储4096 * 16字节（本文栈大小）的0数据（无论是否裁剪--strip-all）。

### 2.4 基于SBI服务完成输出和关机

最终，我们调用软件栈中相比内核更低一层的软件——也即 `RustSBI` 提供的服务来实现格式化输出和遇到致命错误时的关机功能，形成了`LibOS`的核心功能。至此，应用程序可以直接调用 `LibOS` 提供的字符串输出函数或关机函数，达到让应用与硬件隔离的操作系统目标。

具体工作如下：

>* 实现 `sbi_call`，调用RustSBI提供的服务
>* 实现格式化输出
>* 实现panic处理函数，打印相关信息后关机

#### 关于RustSBI

`SBI` 是 `RISC-V Supervisor Binary Interface` 规范的缩写，`OpenSBI` 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用 Rust 语言实现的 SBI。 RustSBI 的功能和 u-boot(SPL) 很类似但相较而言简单很多， 只需要在 boot 阶段为上层应用完成初始化工作后转移控制权给内核。 但是， RustSBI 又直接构成了内核和硬件沟通的桥梁， 为操作系统提供一系列二进制接口，以便其获取和操作硬件信息， RustSBI 能在内核运行时响应内核的请求为内核提供服务。

Western Digital 在 2019 年 12 月的一份 An Introduction to RISC-V Boot Flow 报告中有这么一幅流程图阐述了 RISC-V 的 boot 流程:

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241630148.png" style="zoom: 50%;" />

* **Loader** 要干的事情，就是内存初始化， 以及加载 Runtime 和 BootLoader 程序。 而Loader自己也是一段程序，常见的Loader就包括 BIOS/UEFI， 后者是前者的继任者。
* **Runtime** 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，为 OS 提供服务，当我们要在同一套硬件系统中运行不同的操作系统， 或者做硬件级别的虚拟化时， 就离不开Runtime 服务的支持。 SBI 就是 RISC-V 架构的 Runtime 规范。
* **BootLoader** 要干的事情包括文件系统引导、 网卡引导、 操作系统启动配置项设置、 操作系统加载等等。常见的 BootLoader 包括 GRUB，U-Boot，LinuxBoot 等。
* 而 **BIOS/UEFI** 的大多数实现， 都是 Loader、 Runtime、 BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。 如果把 BIOS 当做一个泛化的术语使用， 而不是指某个具体实现的话， 那么可以认为 SBI 是 BIOS 的组成部分之一。

## *3 //TODO 实验 



# 二 批处理系统

## 1 概述

本章的设计目标是让操作系统能够感知到多个应用程序的存在，并一个接一个地运行这些应用程序，当一个应用程序执行完毕后，会启动下一个应用程序，直到所有的应用程序都执行完毕。

我们将本章的操作系统称为 `BatchOS`，整体架构如下图：

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241630433.png" style="zoom: 25%;" />

通过上图，从Qemu启动到应用程序运行的整体流程如下：

1. Qemu把包含多个app的列表和 `BatchOS` 的image镜像加载到内存中，RustSBI（bootloader）完成基本的硬件初始化后，跳转到 `BatchOS` 起始位置；
2. `BatchOS` 首先进行正常运行前的初始化工作，即建立栈空间和清零bss段，然后通过AppManager内核模块从app列表中依次加载各个app到指定的内存中在用户态执行；
3. App在执行过程中，会通过系统调用的方式得到 `BatchOS` 提供的OS服务，如输出字符串等。

## 2 重点内容梳理

`BatchOS` 主要工作：

* 操作系统层
  * 系统调用 `sys_write/sys_exit` 的实现以及库函数的封装：
    * RISC-V特权模型与Trap
    * 特权隔离机制带来的控制流转移：`user -> os`
      * 用户栈与内核栈
      * Trap 特权级切换引发的应用程序上下文保存与恢复
      * Trap 分发与处理
    * RISC-V ABI (Linux on RV64 系统调用参数约定)
  * 内核模块 `AppManager` 的实现：
    * `load_app`
    * `run_next_app`
* 应用层
  * 编写一组简单测例，自定义 `linker.ld` 以确保这些程序加载到指定的内存地址处；
  * 由于rCore暂不支持动态文件加载（ch6将添加），通过将应用程序的二进制镜像文件作为内核的数据段 `.data` 链接到内核中，以使得内核获取应用程序的信息； 

---

```rust
pub fn rust_main() -> ! {
	//...
    clear_bss();
    trap::init();
    batch::init();
    batch::run_next_app();
}
```

### 2.1 应用层

#### 将应用程序链接到内核

由于目前的内核并不支持动态加载应用程序二进制文件的能力，后续在 `ch6` 会实现文件系统功能。此处提供了一种简单直接的方式让内核能够获取到应用程序的信息从而运行它们，即：在内核正式运行之前，将应用程序的内容直接链接到内核的 `.data` 段中，此时内核和应用程序融合成了一个二进制镜像文件，从而让 `qemu-system-riscv64` 运行它们。具体流程如下：

* 执行 `cargo build` 时，会自动执行 `os/build.rs`，该构建脚本会根据 `usr/` 下的内容动态生成 `link_app.S`。

  ```assembly
  # os/src/link_app.S
  
      .align 3
      .section .data
      .global _num_app
  _num_app:
      .quad 5
      .quad app_0_start
      .quad app_1_start
      .quad app_2_start
      .quad app_3_start
      .quad app_4_start
      .quad app_4_end
  
      .section .data
      .global app_0_start
      .global app_0_end
  app_0_start:
      .incbin "../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin"
  app_0_end:
  
  #...
  ```

* 可以看到，内核能够获取到的信息有：应用程序的数量 `_num_app`，各应用程序的位置信息 `app_*_start/app_*_end` 。内核需要做的工作就是根据以上信息管理并批量执行这些应用程序，这将在 `AppManager` 模块中实现。

#### 自定义应用程序的链接脚本

在 `user/.cargo/config` 中，我们和第一章一样设置链接时使用链接脚本 `user/src/linker.ld` ：

- 将程序的起始物理地址调整为 `0x80400000` ，所有应用程序都会被加载到这个物理地址上运行；
- 将 `_start` 所在的 `.text.entry` 放在整个程序的开头，也就是说批处理系统只要在加载之后跳转到 `0x80400000` 就已经进入了 用户库的入口点，并会在初始化之后跳转到应用程序主逻辑；
- 提供了最终生成可执行文件的 `.bss` 段的起始和终止地址，方便 `clear_bss` 函数使用。

其余的部分和第一章基本相同。

---

内核完成其 `.bss` 段的清零工作，同样应用程序也需要完成这样的工作，通常需要借助用户库。

在 `lib.rs` 中我们定义了用户库的入口点 `_start` ：

```rust
#[no_mangle]
#[link_section = ".text.entry"]
pub extern "C" fn _start() -> ! {
    clear_bss();
    exit(main());
    panic!("unreachable after sys_exit!");
}
```

---

我们还在 `lib.rs` 中看到了另一个 `main` ：

```rust
#[linkage = "weak"]
#[no_mangle]
fn main() -> i32 {
    panic!("Cannot find main!");
}
```

使用 Rust 的宏将其函数符号 `main` 标志为弱链接。这样在最后链接的时候，虽然在 `lib.rs` 和 `bin` 目录下的某个应用程序都有 `main` 符号，但由于 `lib.rs` 中的 `main` 符号是弱链接，链接器会使用 `bin` 目录下的应用主逻辑作为 `main` 。

### 2.2 操作系统层

#### 内核对应用程序的管理: AppManager

我们需要在 OS 中实现一个应用管理器 `AppManager`，它的主要功能是：

- 保存应用数量和各自的位置信息，以及当前执行到第几个应用了。
- 根据应用程序位置信息，初始化好应用所需内存空间，并加载应用执行。

`AppManager` 结构体定义如下：

```rust
// os/src/batch.rs

struct AppManager {
    num_app: usize,
    current_app: usize,
    app_start: [usize; MAX_APP_NUM + 1],
}
```

---

以尽量少的 unsafe code 来初始化 `AppManager` 的全局实例 `APP_MANAGER` ：

```rust
// os/src/batch.rs

lazy_static! {
    static ref APP_MANAGER: UPSafeCell<AppManager> = unsafe { UPSafeCell::new({
        extern "C" { fn _num_app(); }
        let num_app_ptr = _num_app as usize as *const usize;
        let num_app = num_app_ptr.read_volatile();
        let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];
        let app_start_raw: &[usize] =  core::slice::from_raw_parts(
            num_app_ptr.add(1), num_app + 1
        );
        app_start[..=num_app].copy_from_slice(app_start_raw);
        AppManager {
            num_app,
            current_app: 0,
            app_start,
        }
    })};
}
```

---

以上的 `APP_MANAGER` 初始化函数中，只是获取了各应用程序二进制镜像文件的位置信息，内核还需要将具体内容（代码以及数据）加载到内存中，`load_app` 函数如下：

```rust
unsafe fn load_app(&self, app_id: usize) {
    if app_id >= self.num_app {
        panic!("All applications completed!");
    }
    println!("[kernel] Loading app_{}", app_id);
    // clear app area
    core::slice::from_raw_parts_mut(
        APP_BASE_ADDRESS as *mut u8,
        APP_SIZE_LIMIT
    ).fill(0);
    let app_src = core::slice::from_raw_parts(
        self.app_start[app_id] as *const u8,
        self.app_start[app_id + 1] - self.app_start[app_id]
    );
    let app_dst = core::slice::from_raw_parts_mut(
        APP_BASE_ADDRESS as *mut u8,
        app_src.len()
    );
    app_dst.copy_from_slice(app_src);
    // memory fence about fetching the instruction memory
    asm!("fence.i");
}
```

#### RISC-V特权模型与Trap

RISC-V 架构中一共定义了 4 种特权级：

| 级别 | 编码 | 名称                                |
| ---- | ---- | ----------------------------------- |
| 0    | 00   | 用户/应用模式 (U, User/Application) |
| 1    | 01   | 监督模式 (S, Supervisor)            |
| 2    | 10   | 虚拟监督模式 (H, Hypervisor)        |
| 3    | 11   | 机器模式 (M, Machine)               |

其中，级别的数值越大，特权级越高，掌控硬件的能力越强。从表中可以看出， M 模式处在最高的特权级，而 U 模式处于最低的特权级。在CPU硬件层面，除了 M 模式必须存在外，其它模式可以不存在。

以下是支持应用程序运行的一套**执行环境栈：**

![image-20231212110024337](https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202312121100373.png)

* 运行在 M 模式上的软件被称为 **监督模式执行环境 (SEE, Supervisor Execution Environment)，** 如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI；OS 想要获取 SEE 的服务需要通过 SBI。

* 运行在 S 模式上的软件称为**操作系统 OS (Application Execution Environment)，**这是应用程序所依赖的执行环境，想使用OS提供的服务需要通过 ABI，更加通俗的名字为系统调用（syscall）。

  >**应用程序二进制接口** (Application Binary Interface, ABI)，而之所以叫做二进制接口，是因为它与高级编程语言的内部调用接口不同，是机器/汇编指令级的一种接口。

* 运行在 U 模式上的软件就是应用程序，一般情况下真正的应用程序之下还有一层**运行时库执行环境**，但这层环境本质上还是运行在U模式，只是让用户编写应用程序更加方便而已。

我们可以看到在这套执行环境中，除了 `SEE` 使用了现成的 RustSBI，其余的一切我们都需要去实现，不妨分析一下这个流程：

* **控制流的转移：**程序的执行随处可见控制流的转移，追溯到底层硬件无非就是通过一些指令对 `PC` 寄存器的修改。第一章中的函数调用就是最典型的控制流转移场景，且通过 `jalr/ret` 等指令改变了 `PC` 寄存器的值。同时，由于CPU寄存器只有一套，为了保证控制流返回时不破坏原来的程序执行状态，我们需要借助物理内存将这些可能被覆盖的寄存器值保存到特定的内存中，这些寄存器值称为函数调用上下文。

  与之类似，从应用程序到OS层再到SBI层，都会发生函数调用，这意味着控制流的转移。只不过这种函数调用具有特殊性，控制流转移的过程中还伴随着特权级的切换。

* **特权级的切换：**关于CPU为什么存在特权级这个东西，很好理解，无非就是对于硬件上有一些操作不需要或者避免应用程序去完成，这是出于安全性和便捷性考虑，至于应用程序有权限执行哪些操作，可以简单总结为：执行一些基本的逻辑运算操作（加减乘除与或非指令组合而成的操作）是合法的，凡是涉及到硬件资源的访问（输入输出等）都是没有权限的，这个时候就需要切换特权级，让我们的程序置于一个有更高权限的环境中，在这里可以合法执行绝大部分指令。

  这种特权级的切换有更专业的描述：陷入陷出 `Trap`。通常情况下，Trap 指的是从 `U -> S` 的这种由低权限到高权限的特权级切换，从 `S -> U` 称为 Trap Return。其实在RISC-V架构中，Trap是一个相对较大的概念，因为导致特权级切换的场景有很多，归类为：

  * 异常
    * 用户态软件为获得内核态操作系统的服务功能而执行专有特殊指令：执行环境调用 `ECALL`；
    * 在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到；
  * 中断
    * 可以进一步分类为：`SI/TI/EI`，且每种中断类型在不同特权级 `M/S/U` 下有着不同的异常编码；

  我们可以看到，这种控制流的转移伴随着特权级切换，为了区分这些概念，我们可以细分这些控制流：**<font color='red'>函数调用控制流、异常控制流、中断控制流。</font>**

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202312121100279.png" alt="image-20231212105953384" style="zoom:25%;" />

---

这篇文章写的不错：[6.S081——补充材料——RISC-V架构中的异常与中断详解_sret指令-CSDN博客](https://blog.csdn.net/zzy980511/article/details/130642258)

对于 Trap 的触发方式，本章只需要关注 `ECALL` 指令即可。

#### 系统调用与库函数封装

> 现在假设操作系统已经实现好了一切，实际上应用程序执行 `ECALL` 指令会通过硬件机制跳转到某一特定地址执行内核程序。

应用程序通过 `ecall` 调用操作系统提供的接口，由于应用程序运行在用户态（即 U 模式）， `ecall` 指令会触发名为 *Environment call from U-mode* 的异常，并 Trap 进入 S 模式执行操作系统针对这个异常特别提供的服务代码。由于这个接口处于 S 模式的批处理系统和 U 模式的应用程序之间，这个接口可以被称为 ABI 或者系统调用。

我们知道系统调用实际上是汇编指令级的二进制接口，因此这里给出的只是使用 Rust 语言描述的 API 版本。在实际调用的时候，我们需要按照 RISC-V 调用规范（即ABI格式）在合适的寄存器中放置系统调用的参数，然后执行 `ecall` 指令触发 Trap。在 Trap 回到 U 模式的应用程序代码之后，会从 `ecall` 的下一条指令继续执行，同时我们能够按照调用规范在合适的寄存器中读取返回值。

在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 `a0~a6` 保存系统调用的参数， `a0` 保存系统调用的返回值。有些许不同的是寄存器 `a7` 用来传递 syscall ID，这是因为所有的 syscall 都是通过 `ecall` 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。由于这超出了 Rust 语言的表达能力，我们需要在代码中使用内嵌汇编来完成参数/返回值绑定和 `ecall` 指令的插入：

```rust
// user/src/syscall.rs
use core::arch::asm;
fn syscall(id: usize, args: [usize; 3]) -> isize {
    let mut ret: isize;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") args[0] => ret,
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id
        );
    }
    ret
}
```

>**RISC-V 寄存器编号和别名**
>
>RISC-V 寄存器编号从 `0~31` ，表示为 `x0~x31` 。 其中：
>
>- `x10~x17` : 对应 `a0~a7`
>- `x1` ：对应 `ra`

从 RISC-V 调用规范来看，就像函数有着输入参数和返回值一样， `ecall` 指令同样有着输入和输出寄存器： `a0~a2` 和 `a7` 作为输入寄存器分别表示系统调用参数和系统调用 ID ，而当系统调用返回后， `a0` 作为输出寄存器保存系统调用的返回值。在函数上下文中，输入参数数组 `args` 和变量 `id` 保存系统调用参数和系统调用 ID ，而变量 `ret` 保存系统调用返回值，它也是函数 `syscall` 的输出/返回值。这些输入/输出变量可以和 `ecall` 指令的输入/输出寄存器一一对应。

---

`user/src/lib.rs` 封装了一套应用程序执行框架，可以让应用程序批量自动化执行，`main` 函数完成后会执行 `sys_exit` 系统调用：

```rust
#[no_mangle]
#[link_section = ".text.entry"]
pub extern "C" fn _start() -> ! {
    clear_bss();
    exit(main());
    panic!("unreachable after sys_exit!");
}

pub fn exit(exit_code: i32) -> isize {
    sys_exit(exit_code)
}
```

#### 特权隔离机制: 用户态与内核态

在RISC-V特权模型的分析中，我们梳理了特权级切换的流程，内核需要完成应用程序Trap上下文的保存与恢复工作。本章我们最终目的是在rCore上跑应用程序，那就看看**从内核启动到应用程序批量执行完毕**的整个过程中，rCore需要实现哪些基本功能：

- 当内核执行应用程序之前，需要初始化应用程序的用户态上下文，并能切换到用户态执行应用程序；
- 当应用程序发起系统调用（即发出 Trap）之后，需要到批处理操作系统中进行处理；
- 当应用程序执行出错的时候，需要到批处理操作系统中杀死该应用并加载运行下一个应用；
- 当应用程序执行结束的时候，需要到批处理操作系统中加载运行下一个应用（实际上也是通过系统调用 `sys_exit` 来实现的）。

特权隔离机制需要操作系统和硬件共同实现，这里只梳理软件相关内容。

硬件机制：https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#trap-hw-mechanism

---

##### 用户栈与内核栈

在 Trap 触发的一瞬间， CPU 就会切换到 S 特权级并跳转到 `stvec` 所指示的位置。但是在正式进入 S 特权级的 Trap 处理之前，内核必须保存原控制流的寄存器状态，这一般通过内核栈来保存。注意，我们需要用专门为操作系统准备的内核栈，而不是应用程序运行时用到的用户栈。

使用两个不同的栈主要是为了安全性：如果两个控制流（即应用程序的控制流和内核的控制流）使用同一个栈，在返回之后应用程序就能读到 Trap 控制流的历史信息，比如内核一些函数的地址，这样会带来安全隐患。

---

##### Trap管理

首先来看一下应用程序的 Trap 上下文 `TrapContext`，定义如下：

```rust
// os/src/trap/context.rs

#[repr(C)]
pub struct TrapContext {
    pub x: [usize; 32],
    pub sstatus: Sstatus,
    pub sepc: usize,
}
```

为什么需要保存 `sstatus` 和 `spec`？对于 CSR 而言，我们知道进入 Trap 的时候，硬件会立即覆盖掉 `scause/stval/sstatus/sepc` 的全部或是其中一部分：

* `scause/stval` 的情况是：它总是在 Trap 处理的第一时间就被使用或者是在其他地方保存下来了，因此它没有被修改并造成不良影响的风险；
* 而对于 `sstatus/sepc` 而言，它们会在 Trap 处理的全程有意义（在 Trap 控制流最后 `sret` 的时候还用到了它们），而且确实会出现 Trap 嵌套的情况使得它们的值被覆盖掉。所以我们需要将它们也一起保存下来，并在 `sret` 之前恢复原样。

> ***Trap 上下文保存与恢复***

在批处理操作系统初始化的时候，我们需要修改 `stvec` 寄存器来指向正确的 Trap 处理入口点：

```rust
// os/src/trap/mod.rs

global_asm!(include_str!("trap.S"));

pub fn init() {
    extern "C" { fn __alltraps(); }
    unsafe {
        stvec::write(__alltraps as usize, TrapMode::Direct);
    }
}
```

首先是保存 Trap 上下文的 `__alltraps` 的实现：

```assembly
# os/src/trap/trap.S

.macro SAVE_GP n
    sd x\n, \n*8(sp)
.endm

.align 2
__alltraps:
    csrrw sp, sscratch, sp
    # now sp->kernel stack, sscratch->user stack
    # allocate a TrapContext on kernel stack
    addi sp, sp, -34*8
    # save general-purpose registers
    sd x1, 1*8(sp)
    # skip sp(x2), we will save it later
    sd x3, 3*8(sp)
    # skip tp(x4), application does not use it
    # save x5~x31
    .set n, 5
    .rept 27
        SAVE_GP %n
        .set n, n+1
    .endr
    # we can use t0/t1/t2 freely, because they were saved on kernel stack
    csrr t0, sstatus
    csrr t1, sepc
    sd t0, 32*8(sp)
    sd t1, 33*8(sp)
    # read user stack from sscratch and save it on the kernel stack
    csrr t2, sscratch
    sd t2, 2*8(sp)
    # set input argument of trap_handler(cx: &mut TrapContext)
    mv a0, sp
    call trap_handler
```

当 `trap_handler` 返回之后会从调用 `trap_handler` 的下一条指令开始执行，也就是从栈上的 Trap 上下文恢复的 `__restore` ：

```assembly
# os/src/trap/trap.S

.macro LOAD_GP n
    ld x\n, \n*8(sp)
.endm

__restore:
    # case1: start running app by __restore
    # case2: back to U after handling trap
    mv sp, a0
    # now sp->kernel stack(after allocated), sscratch->user stack
    # restore sstatus/sepc
    ld t0, 32*8(sp)
    ld t1, 33*8(sp)
    ld t2, 2*8(sp)
    csrw sstatus, t0
    csrw sepc, t1
    csrw sscratch, t2
    # restore general-purpuse registers except sp/tp
    ld x1, 1*8(sp)
    ld x3, 3*8(sp)
    .set n, 5
    .rept 27
        LOAD_GP %n
        .set n, n+1
    .endr
    # release TrapContext on kernel stack
    addi sp, sp, 34*8
    # now sp->kernel stack, sscratch->user stack
    csrrw sp, sscratch, sp
    sret
```

**sscratch CSR 的用途**

从上面的汇编代码中可以看出，在保存 Trap 上下文的时候，它起到了两个作用：首先是保存了内核栈的地址，其次它可作为一个中转站让 `sp` （目前指向的用户栈的地址）的值可以暂时保存在 `sscratch` 。这样仅需一条 `csrrw sp, sscratch, sp` 指令（交换对 `sp` 和 `sscratch` 两个寄存器内容）就完成了从用户栈到内核栈的切换，这是一种极其精巧的实现。

> ***Trap 分发与处理***

`trap_handler` 函数中完成分发和处理：

```rust
// os/src/trap/mod.rs

#[no_mangle]
pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read();
    let stval = stval::read();
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            cx.sepc += 4;
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
        Trap::Exception(Exception::StoreFault) |
        Trap::Exception(Exception::StorePageFault) => {
            println!("[kernel] PageFault in application, kernel killed it.");
            run_next_app();
        }
        Trap::Exception(Exception::IllegalInstruction) => {
            println!("[kernel] IllegalInstruction in application, kernel killed it.");
            run_next_app();
        }
        _ => {
            panic!("Unsupported trap {:?}, stval = {:#x}!", scause.cause(), stval);
        }
    }
    cx
}

// os/src/syscall/mod.rs

pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize {
    match syscall_id {
        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),
        SYSCALL_EXIT => sys_exit(args[0] as i32),
        _ => panic!("Unsupported syscall_id: {}", syscall_id),
    }
}

// os/src/syscall/process.rs

pub fn sys_exit(xstate: i32) -> ! {
    println!("[kernel] Application exited with code {}", xstate);
    run_next_app()
}
```

整体Trap处理流程如下图所示：

![](https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241631829.png)

---

##### 内核如何启动应用程序

当批处理操作系统初始化完成，或者是某个应用程序运行结束或出错的时候，我们要调用 `run_next_app` 函数切换到下一个应用程序。此时 CPU 运行在 S 特权级，而它希望能够切换到 U 特权级。在 RISC-V 架构中，唯一能够使得 CPU 特权级下降的方法就是执行 Trap 返回的特权指令，如 `sret` 、`mret` 等。事实上，在从操作系统内核返回到运行应用程序之前，要完成如下这些工作：

- 构造应用程序开始执行所需的 Trap 上下文；
- 通过 `__restore` 函数，从刚构造的 Trap 上下文中，恢复应用程序执行的部分寄存器；
- 设置 `sepc` CSR的内容为应用程序入口点 `0x80400000`；
- 切换 `scratch` 和 `sp` 寄存器，设置 `sp` 指向应用程序用户栈；
- 执行 `sret` 从 S 特权级切换到 U 特权级。

它们可以通过复用 `__restore` 的代码来更容易的实现上述工作。我们只需要在内核栈上压入一个**为启动应用程序而特殊构造的 Trap 上下文，**再通过 `__restore` 函数，就能让这些寄存器到达启动应用程序所需要的上下文状态。

```rust
// os/src/trap/context.rs

impl TrapContext {
    pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; }
    pub fn app_init_context(entry: usize, sp: usize) -> Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
        };
        cx.set_sp(sp);
        cx
    }
}

// os/src/batch.rs

pub fn run_next_app() -> ! {
    let mut app_manager = APP_MANAGER.exclusive_access();
    let current_app = app_manager.get_current_app();
    unsafe {
        app_manager.load_app(current_app);
    }
    app_manager.move_to_next_app();
    drop(app_manager);
    // before this we have to drop local variables related to resources manually
    // and release the resources
    extern "C" { fn __restore(cx_addr: usize); }
    unsafe {
        __restore(KERNEL_STACK.push_context(
            TrapContext::app_init_context(APP_BASE_ADDRESS, USER_STACK.get_sp())
        ) as *const _ as usize);
    }
    panic!("Unreachable in batch::run_current_app!");
}
```

`run_next_app` 函数在内核栈上压入一个 Trap 上下文，其 `sepc` 是应用程序入口地址 `0x80400000` ，其 `sp` 寄存器指向用户栈，其 `sstatus` 的 `SPP` 字段被设置为 User 。`push_context` 的返回值是内核栈压入 Trap 上下文之后的栈顶，它会被作为 `__restore` 的参数（回看 [__restore 代码](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#code-restore) ，这时我们可以理解为何 `__restore` 函数的起始部分会完成 sp←a0 ），这使得在 `__restore` 函数中 `sp` 仍然可以指向内核栈的栈顶。这之后，就和执行一次普通的 `__restore` 函数调用一样了。



## 3 疑难解决

* 根据 Rust 程序设计语言 中的描述， 创建一个允许其他语言调用的 Rust 函数需要添加 `extern` 标识。 另外 `#[no_mangle]` 能保证 Rust 函数名不会被编译器处理变得难以阅读与定位， 使其保留原有的名称方便被其他语言指定与链接。

  ```rust
   #[no_mangle]
   #[link_section = ".text.entry"]
   pub extern "C" fn _start() -> ! {
       clear_bss();
       exit(main());
       panic!("unreachable after sys_exit!");
   }
  ```

* [Linux kernel system calls for all architectures](https://marcin.juszkiewicz.com.pl/download/tables/syscalls.html) 中可以查阅 RISCV-64 规约的系统函数调用的接口与调用的 ID 号。

* **`os/build.rs` 构建脚本**

  > 构建脚本会在项目被构建之前 **Cargo 会编译构建脚本生成可执行文件并执行相应的任务，** 其多用于 C 依赖库构建， 或指定依赖库， 以及进行平台的配置等预处理过程。 在 rCore 的项目中， os 项目工程的根目录下的 build.rs 主要完成的是链接功能性的二进制工具， 静态链接这些测试文件以在后续运行时动态调用。

* **Rust 模块系统解析**

  [对Rust的模块系统的清晰解释](https://skyao.io/learning-rust/docs/build/module/rust-module-system-explanation/)

* 关于 `KernelStack` 和 `UserStack`

  >未初始化的全局变量和局部静态变量默认值都是 0， 一般来说会将这部分信息存放在 `.bss` 段并预留未定义的全局变量符号。 这里声明了一个全局静态变量并强制 4096 对齐。 通过 `readelf -t os/target/riscv64gc-unknown-none-elf/release/os` 读取编译出的 ELF 文件， `.rodata` 段被 4096 对齐了， 更改栈的大小也能确认 KernelStack 以及 UserStack 被放在了 `.rodata` 中。 初始化为 0 的全局变量和未初始化的全局变量的性质应当一致， 但这里出现了例外。 Rust 中的 static 变量实际声明了一段固定的内存空间且其中的内容不可变， 猜测 Rust 编译器倾向于将只读部分的预留内存保存在 `.rodata` 段。
  >
  >最简单的办法就是将 USER_STACK 以及 KERNEL_STACK 这两个变量声明为 static mut 类型， 就能将这两块内存初始化为 `.bss` 段。

* `static mut` 与 `UnsafeCell`

* 关于 Trap 触发后的 `sepc` 寄存器的设置情况

  > 在 trap_handler 中， 对于 Exception::UserEnvCall 异常， 有一个更新 sepc 寄存器信息的指令为 cx.sepc += 4，存在这样一个解释：
  >
  > 中断和异常的触发方式不同， 因此硬件设置的“默认执行的下一条指令的地址”也不同。 异常是由于一条指令的执行触发的， 此时硬件默认会将 sepc 仍然设置为这条指令的地址， 等内核处理完之后再执行一次， 期待这次指令能够正常执行； 而中断是在一条指令执行完毕之后， CPU 检测到了中断， 此时硬件会将 sepc 设置为下一条指令的地址， 因为没有任何理由再执行一次刚刚执行完的指令。



## *4 //TODO 实验



# 三 分时多任务系统

## 1 概述

本章一次性介绍了多个版本的操作系统，分别为 `Multiprog oS`、`Coop OS`、`Timsharing OS`：

> **多道程序操作系统 `Multiprog OS`**

和上一章 `BatchOS` 的唯一区别在于：改进的 AppManager 内核模块从app列表中把所有app都加载到内存中，并按指定顺序让app在用户态一个接一个地执行。

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202312121451282.png" alt="image-20231212145103016" style="zoom:25%;" />

> **协作式操作系统 `Coop OS`**

相对于 `Multiprog OS`，`Coop OS` 进一步改进了 AppManager 内核模块，把它拆分为负责加载应用的 Loader 内核模块和管理应用运行过程的 TaskManager 内核模块。 TaskManager 通过 task 任务控制块来管理应用程序的执行过程，**支持应用程序主动放弃 CPU 并切换到另一个应用继续执行，**从而提高系统整体执行效率。

每个应用程序在运行时有自己所在的内存空间和栈，确保被切换时相关信息不会被其他应用破坏。如果当前应用程序正在运行，则该应用对应的任务处于运行（Running）状态；如果该应用主动放弃处理器，则该应用对应的任务处于就绪（Ready）状态。操作系统进行任务切换时，需要把要暂停任务的上下文（即任务用到的通用寄存器）保存起来，把要继续执行的任务的上下文恢复为暂停前的内容，这样就能让不同的应用协同使用处理器了。

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241632734.png" style="zoom:25%;" />

> **分时多任务操作系统 `Timesharing OS`**

相对于 `CoopOS`，`TimesharingOS` 最大的变化是：

* 改进了 Trap_handler 内核模块，支持时钟中断，从而可以抢占应用的执行；
* 改进了 TaskManager 内核模块，提供任务调度功能，这样可以在收到时钟中断后统计任务的使用时间片，如果任务的时间片用完后，则切换任务。从而可以公平和高效地分时执行多个应用，提高系统的整体效率。

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241634324.png" style="zoom:25%;" />

---

本章的最终目标是实现更现代化的 `TimeSharing OS`，中间经历了 `Multiprog OS` 和 `Coop OS` 的演进过程，重点内容如下：

* `Multiprog OS`
  * 多个应用同时放在内存中，所以他们的起始地址是不同的，且地址范围不能重叠；
* `Coop OS`
  * 在上一章的 Trap 上下文切换的基础上，再加上一个 Task 上下文切换，才能完成完整的任务切换；
  * 应用程序可以在用户态执行中主动暂停，这需要有新的系统调用 `sys_yield` 的实现来支持；
* `TimSharing OS`
  * 为了支持抢占应用执行的抢占式切换，还要添加对时钟中断的处理，这部分主要是通过对 `trap_handler` 函数中进行扩展，来完成在时钟中断产生时可能进行的任务切换。

---

```rust
#[no_mangle]
pub fn rust_main() -> ! {
    clear_bss();
    println!("[kernel] Hello, world!");
    trap::init();
    loader::load_apps();
    trap::enable_timer_interrupt();
    timer::set_next_trigger();
    task::run_first_task();
    panic!("Unreachable in rust_main!");
}
```

## 2 重点内容梳理

### 2.1 Multiprog OS

所谓 ”多道程序操作系统“，就是将多个应用程序一次性地加载到内存中，每个应用都有不同的和OS协议好的特定内存地址，内核不需要像上一章中只有清空前一个应用后才能加载另一个应用程序。

#### 多道程序放置

由于每个应用被加载到的位置都不同，也就导致它们的链接脚本 `linker.ld` 中的 `BASE_ADDRESS` 都是不同的。实际上，我们不是直接用 `cargo build` 构建应用的链接脚本，而是写了一个脚本定制工具 `build.py` ，为每个应用定制了各自的链接脚本。

#### 多道程序加载

本章中，所有的应用在内核初始化的时候就一并被加载到内存中。为了避免覆盖，它们自然需要被加载到不同的物理地址。这是通过调用 `loader` 子模块的 `load_apps` 函数实现的：

```rust
// os/src/loader.rs

 pub fn load_apps() {
     extern "C" { fn _num_app(); }
     let num_app_ptr = _num_app as usize as *const usize;
     let num_app = get_num_app();
     let app_start = unsafe {
         core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
     };
     // clear i-cache first
     unsafe { asm!("fence.i" :::: "volatile"); }
     // load apps
     for i in 0..num_app {
         let base_i = get_base_i(i);
         // clear region
         (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe {
             (addr as *mut u8).write_volatile(0)
         });
         // load app from data section to memory
         let src = unsafe {
             core::slice::from_raw_parts(
                 app_start[i] as *const u8,
                 app_start[i + 1] - app_start[i]
             )
         };
         let dst = unsafe {
             core::slice::from_raw_parts_mut(base_i as *mut u8, src.len())
         };
         dst.copy_from_slice(src);
     }
 }
```

#### 执行应用程序

当多道程序的初始化放置工作完成，或者是某个应用程序运行结束或出错的时候，我们要调用 `run_next_app` 函数切换到下一个应用程序。此时 CPU 运行在 S 特权级的操作系统中，而操作系统希望能够切换到 U 特权级去运行应用程序。相对不同的是，操作系统知道每个应用程序预先加载在内存中的位置，这就需要**设置应用程序返回的不同 Trap 上下文**（Trap 上下文中保存了放置程序起始地址的 `sepc` 寄存器内容）：

- 跳转到应用程序（编号 i ）的入口点 `entry_i`
- 将使用的栈切换到用户栈 `stack_i`

### 2.2 Coop OS

#### 任务切换的设计与实现

https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/2task-switching.html#term-task-switch-impl

事实上，任务切换是来自两个不同应用在内核中的 Trap 控制流之间的切换。当一个应用 Trap 到 S 模式的操作系统内核中进行进一步处理（即进入了操作系统的 Trap 控制流）的时候，其 Trap 控制流可以调用一个特殊的 `__switch` 函数。这个函数表面上就是一个普通的函数调用：在 `__switch` 返回之后，将继续从调用该函数的位置继续向下执行。但是其间却隐藏着复杂的控制流切换过程。

具体来说，调用 `__switch` 之后直到它返回前的这段时间，原 Trap 控制流 *A* 会先被暂停并被切换出去， CPU 转而运行另一个应用在内核中的 Trap 控制流 *B* 。然后在某个合适的时机，原 Trap 控制流 *A* 才会从某一条 Trap 控制流 *C* （很有可能不是它之前切换到的 *B* ）切换回来继续执行并最终返回。不过，从实现的角度讲， `__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** 。

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202312121622624.png" alt="image-20231212162201674" style="zoom:80%;" />

当 Trap 控制流准备调用 `__switch` 函数使任务从运行状态进入暂停状态的时候，让我们考察一下它内核栈上的情况。如上图左侧所示，在准备调用 `__switch` 函数之前，内核栈上从栈底到栈顶分别是保存了应用执行状态的 Trap 上下文以及内核在对 Trap 处理的过程中留下的调用栈信息。由于之后还要恢复回来执行，我们必须保存 CPU 当前的某些寄存器，我们称它们为 **任务上下文** (Task Context)。

我们会在稍后介绍里面需要包含哪些寄存器。至于上下文保存的位置，下一节在我们会介绍任务管理器 `TaskManager` ，在里面能找到一个数组 `tasks` ，其中的每一项都是一个任务控制块即 `TaskControlBlock` ，它负责保存一个任务的状态，而任务上下文 `TaskContext` 被保存在任务控制块中。在内核运行时我们会初始化 `TaskManager` 的全局实例 `TASK_MANAGER` ，因此所有任务上下文实际保存在在 `TASK_MANAGER` 中，从内存布局来看则是放在内核的全局数据 `.data` 段中。当我们将任务上下文保存完毕之后则转化为下图右侧的状态。当要从其他任务切换回来继续执行这个任务的时候，CPU 会读取同样的位置并从中恢复任务上下文。

对于当前正在执行的任务的 Trap 控制流，我们用一个名为 `current_task_cx_ptr` 的变量来保存放置当前任务上下文的地址；而用 `next_task_cx_ptr` 的变量来保存放置下一个要执行任务的上下文的地址。

接下来我们同样从栈上内容的角度来看 `__switch` 的整体流程：

<img src="C:/Users/26896/AppData/Roaming/Typora/typora-user-images/image-20231212162349189.png" alt="image-20231212162349189" style="zoom:25%;" />

Trap 控制流在调用 `__switch` 之前就需要明确知道即将切换到哪一条目前正处于暂停状态的 Trap 控制流，因此 `__switch` 有两个参数，第一个参数代表它自己，第二个参数则代表即将切换到的那条 Trap 控制流。这里我们用上面提到过的 `current_task_cx_ptr` 和 `next_task_cx_ptr` 作为代表。在上图中我们假设某次 `__switch` 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段，在每个阶段中我们都给出了 A 和 B 内核栈上的内容。

- 阶段 [1]：在 Trap 控制流 A 调用 `__switch` 之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的；
- 阶段 [2]：A 在 A 任务上下文空间在里面保存 CPU 当前的寄存器快照；
- 阶段 [3]：这一步极为关键，读取 `next_task_cx_ptr` 指向的 B 任务上下文，根据 B 任务上下文保存的内容来恢复 `ra` 寄存器、`s0~s11` 寄存器以及 `sp` 寄存器。只有这一步做完后， `__switch` 才能做到一个函数跨两条控制流执行，即 *通过换栈也就实现了控制流的切换* 。
- 阶段 [4]：上一步寄存器恢复完成后，可以看到通过恢复 `sp` 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。这就是为什么 `__switch` 能做到一个函数跨两条控制流执行。此后，当 CPU 执行 `ret` 汇编伪指令完成 `__switch` 函数返回后，任务 B 可以从调用 `__switch` 的位置继续向下执行。

从结果来看，我们看到 A 控制流 和 B 控制流的状态发生了互换， A 在保存任务上下文之后进入暂停状态，而 B 则恢复了上下文并在 CPU 上继续执行。

---

下面我们给出 `__switch` 的实现：

```assembly
# os/src/task/switch.S

.altmacro
.macro SAVE_SN n
    sd s\n, (\n+2)*8(a0)
.endm
.macro LOAD_SN n
    ld s\n, (\n+2)*8(a1)
.endm
    .section .text
    .globl __switch
__switch:
    # 阶段 [1]
    # __switch(
    #     current_task_cx_ptr: *mut TaskContext,
    #     next_task_cx_ptr: *const TaskContext
    # )
    # 阶段 [2]
    # save kernel stack of current task
    sd sp, 8(a0)
    # save ra & s0~s11 of current execution
    sd ra, 0(a0)
    .set n, 0
    .rept 12
        SAVE_SN %n
        .set n, n + 1
    .endr
    # 阶段 [3]
    # restore ra & s0~s11 of next execution
    ld ra, 0(a1)
    .set n, 0
    .rept 12
        LOAD_SN %n
        .set n, n + 1
    .endr
    # restore kernel stack of next task
    ld sp, 8(a1)
    # 阶段 [4]
    ret
```

保存 `ra` 很重要，它记录了 `__switch` 函数返回之后应该跳转到哪里继续执行，从而在任务切换完成并 `ret` 之后能到正确的位置。对于一般的函数而言，Rust/C 编译器会在函数的起始位置自动生成代码来保存 `s0~s11` 这些被调用者保存的寄存器。但 `__switch` 是一个用汇编代码写的特殊函数，它不会被 Rust/C 编译器处理，所以我们需要在 `__switch` 中手动编写保存 `s0~s11` 的汇编代码。 <font color='red'>不用保存其它寄存器是因为：其它寄存器中，属于调用者保存的寄存器是由编译器在高级语言编写的调用函数中自动生成的代码来完成保存的；还有一些寄存器属于临时寄存器，不需要保存和恢复。</font>

我们会将这段汇编代码中的全局符号 `__switch` 解释为一个 Rust 函数：

```rust
// os/src/task/switch.rs

global_asm!(include_str!("switch.S"));

use super::TaskContext;

extern "C" {
    pub fn __switch(
        current_task_cx_ptr: *mut TaskContext,
        next_task_cx_ptr: *const TaskContext
    );
}

// os/src/task/context.rs

pub struct TaskContext {
    ra: usize,
    sp: usize,
    s: [usize; 12],
}
```

<font color='red'>我们会调用该函数来完成切换功能而不是直接跳转到符号 `__switch` 的地址。因此在调用前后 Rust 编译器会自动帮助我们插入保存/恢复调用者保存寄存器的汇编代码。</font>

> 仔细观察的话可以发现 `TaskContext` 很像一个普通函数栈帧中的内容。正如之前所说， `__switch` 的实现除了换栈之外几乎就是一个普通函数，也能在这里得到体现。尽管如此，二者的内涵却有着很大的不同。

---

#### 内核对任务的管理

##### 任务控制块与任务运行状态

我们必须在内核中对每个应用分别维护它的运行状态，目前有如下几种：

```rust
// os/src/task/task.rs

#[derive(Copy, Clone, PartialEq)]
pub enum TaskStatus {
    UnInit, // 未初始化
    Ready, // 准备运行
    Running, // 正在运行
    Exited, // 已退出
}
```

内核还需要保存一个应用的更多信息，我们将它们都保存在一个名为**任务控制块** (Task Control Block) 的数据结构中：

```rust
// os/src/task/task.rs

#[derive(Copy, Clone)]
pub struct TaskControlBlock {
    pub task_status: TaskStatus,
    pub task_cx: TaskContext,
}
```

##### 任务管理器

我们还需要一个全局的任务管理器来管理这些用任务控制块描述的应用：

```rust
// os/src/task/mod.rs

pub struct TaskManager {
    num_app: usize,
    inner: UPSafeCell<TaskManagerInner>,
}

struct TaskManagerInner {
    tasks: [TaskControlBlock; MAX_APP_NUM],
    current_task: usize,
}
```

我们可重用并扩展之前初始化 `TaskManager` 的全局实例 `TASK_MANAGER` ：

```rust
// os/src/task/mod.rs

lazy_static! {
    pub static ref TASK_MANAGER: TaskManager = {
        let num_app = get_num_app();
        let mut tasks = [
            TaskControlBlock {
                task_cx: TaskContext::zero_init(),
                task_status: TaskStatus::UnInit
            };
            MAX_APP_NUM
        ];
        for i in 0..num_app {
            tasks[i].task_cx = TaskContext::goto_restore(init_app_cx(i));
            tasks[i].task_status = TaskStatus::Ready;
        }
        TaskManager {
            num_app,
            inner: unsafe { UPSafeCell::new(TaskManagerInner {
                tasks,
                current_task: 0,
            })},
        }
    };
}
```

---

#### yield系统调用

一个应用会持续运行下去，直到它主动调用 `sys_yield` 系统调用来交出 CPU 使用权。内核将很大的权力下放到应用，让所有的应用互相协作来最终达成最大化 CPU 利用率，充分利用计算资源这一终极目标。在计算机发展的早期，由于应用基本上都是一些简单的计算任务，且程序员都比较遵守规则，因此内核可以信赖应用，这样协作式的方案是没有问题的。

注意，调用 `sys_yield` 不一定与外设有关。随着内核功能的逐渐复杂，我们还会遇到其他需要等待的事件，我们都可以立即调用 `sys_yield` 来避免等待过程造成的浪费。

`sys_yield` 代码如下：

```rust
// os/src/syscall/process.rs

use crate::task::suspend_current_and_run_next;

pub fn sys_yield() -> isize {
    suspend_current_and_run_next();
    0
}

// os/src/task/mod.rs

pub fn suspend_current_and_run_next() {
    mark_current_suspended();
    run_next_task();
}
```

重点看 `run_next_task` 的实现，之前的 `__swicth` 函数在此处调用：

```rust
// os/src/task/mod.rs

fn run_next_task() {
    TASK_MANAGER.run_next_task();
}

impl TaskManager {
    fn run_next_task(&self) {
        if let Some(next) = self.find_next_task() {
            let mut inner = self.inner.exclusive_access();
            let current = inner.current_task;
            inner.tasks[next].task_status = TaskStatus::Running;
            inner.current_task = next;
            let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext;
            let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext;
            drop(inner);
            // before this, we should drop local variables that must be dropped manually
            unsafe {
                __switch(
                    current_task_cx_ptr,
                    next_task_cx_ptr,
                );
            }
            // go back to user mode
        } else {
            panic!("All applications completed!");
        }
    }
}
```

总结一下当前 OS 视角下的应用状态变化图：

<img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202311241633764.png" style="zoom: 50%;" />

#### 内核首次进入用户态

https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/3multiprogramming.html#id7

当被任务切换出去的应用即将再次运行的时候，它实际上是通过 `__switch` 函数又完成一次任务切换，只是这次是被切换进来，取得了 CPU 的使用权。如果该应用是之前被切换出去的，那么它需要有任务上下文和内核栈上的 Trap 上下文，让切换机制可以正常工作。但是如果应用是第一次被执行，那内核应该怎么办呢？类似构造 Trap 上下文的方法，内核需要在应用的任务控制块上构造一个用于第一次执行的任务上下文。我们是在创建 `TaskManager` 的全局实例 `TASK_MANAGER` 的时候来进行这个初始化的。

```rust
// os/src/task/mod.rs

for i in 0..num_app {
    tasks[i].task_cx = TaskContext::goto_restore(init_app_cx(i));
    tasks[i].task_status = TaskStatus::Ready;
}

// os/src/task/context.rs

impl TaskContext {
    pub fn goto_restore(kstack_ptr: usize) -> Self {
        extern "C" { fn __restore(); }
        Self {
            ra: __restore as usize,
            sp: kstack_ptr,
            s: [0; 12],
        }
    }
}

// os/src/loader.rs

pub fn init_app_cx(app_id: usize) -> usize {
    KERNEL_STACK[app_id].push_context(
        TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()),
    )
}
```

对于每个任务，我们先调用 `init_app_cx` 构造该任务的 Trap 上下文（包括应用入口地址和用户栈指针）并将其压入到内核栈顶。接着调用 `TaskContext::goto_restore` 来构造每个任务保存在任务控制块中的任务上下文。它设置任务上下文中的内核栈指针将任务上下文的 `ra` 寄存器设置为 `__restore` 的入口地址。这样，在 `__switch` 从它上面恢复并返回之后就会直接跳转到 `__restore` ，此时栈顶是一个我们构造出来第一次进入用户态执行的 Trap 上下文，就和第二章的情况一样了。

需要注意的是， `__restore` 的实现需要做出变化：它 **不再需要** 在开头 `mv sp, a0` 了。因为在 `__switch` 之后，`sp` 就已经正确指向了我们需要的 Trap 上下文地址。

在 `rust_main` 中我们调用 `task::run_first_task` 来开始应用的执行：

```rust
// os/src/task/mod.rs

impl TaskManager {
    fn run_first_task(&self) -> ! {
        let mut inner = self.inner.exclusive_access();
        let task0 = &mut inner.tasks[0];
        task0.task_status = TaskStatus::Running;
        let next_task_cx_ptr = &task0.task_cx as *const TaskContext;
        drop(inner);
        let mut _unused = TaskContext::zero_init();
        // before this, we should drop local variables that must be dropped manually
        unsafe {
            __switch(
                &mut _unused as *mut TaskContext,
                next_task_cx_ptr,
            );
        }
        panic!("unreachable in run_first_task!");
    }

pub fn run_first_task() {
    TASK_MANAGER.run_first_task();
}
```

### 2.3 Timesharing OS

如果应用自己很少 yield ，操作系统内核就要开始收回之前下放的权力，由它自己对 CPU 资源进行集中管理并合理分配给各应用，这就是内核需要提供的任务调度能力。我们可以将多道程序的调度机制分类成 **协作式调度** (Cooperative Scheduling) ，因为它的特征是：只要一个应用不主动 yield 交出 CPU 使用权，它就会一直执行下去。与之相对， **抢占式调度** (Preemptive Scheduling) 则是应用 *随时* 都有被内核切换出去的可能。

现代的任务调度算法基本都是抢占式的，它要求每个应用只能连续执行一段时间，然后内核就会将它强制性切换出去。一般将 **时间片** (Time Slice) 作为应用连续执行时长的度量单位，每个时间片可能在毫秒量级。调度算法需要考虑：每次在换出之前给一个应用多少时间片去执行，以及要换入哪个应用。

本章中我们仅需要最原始的 RR 算法，用文字描述的话就是维护一个任务队列，每次从队头取出一个应用执行一个时间片，然后把它丢到队尾，再继续从队头取出一个应用，以此类推直到所有的应用执行完毕。

#### 时钟中断和计时器

RISC-V 架构的中断机制：https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/4time-sharing-system.html#risc-v

[6.S081——补充材料——RISC-V架构中的异常与中断详解_sret指令-CSDN博客](https://blog.csdn.net/zzy980511/article/details/130642258)

由于软件（特别是操作系统）需要一种计时机制，RISC-V 架构要求处理器要有一个内置时钟，其频率一般低于 CPU 主频。实现时钟中断所必须的寄存器：

* 在 RISC-V 64 架构上，CSR `mtime` 用于保存 CPU 内置时钟自上电以来所经历的时钟周期数，我们无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的；
* 另外一个 64 位的 CSR `mtimecmp` 的作用是：一旦计数器 `mtime` 的值超过了 `mtimecmp`，就会触发一次时钟中断。这使得我们可以方便的通过设置 `mtimecmp` 的值来决定下一次时钟中断何时触发；

`set_next_trigger` 函数用于触发一次某特定时间间隔的 S 模式时钟中断：

```rust
// os/src/timer.rs

use riscv::register::time;

pub fn get_time() -> usize {
    time::read()
}

// os/src/sbi.rs

const SBI_SET_TIMER: usize = 0;

pub fn set_timer(timer: usize) {
    sbi_call(SBI_SET_TIMER, timer, 0, 0);
}

// os/src/timer.rs

use crate::config::CLOCK_FREQ;
const TICKS_PER_SEC: usize = 100;

pub fn set_next_trigger() {
    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);
}
```

#### 抢占式调度

我们只需在 `trap_handler` 函数下新增一个条件分支跳转，当发现触发了一个 S 特权级时钟中断的时候，首先重新设置一个 10ms 的计时器，然后调用 `suspend_current_and_run_next` 函数暂停当前应用并切换到下一个。

```rust
// os/src/trap/mod.rs

match scause.cause() {
    Trap::Interrupt(Interrupt::SupervisorTimer) => {
        set_next_trigger();
        suspend_current_and_run_next();
    }
}
```

为了避免 S 特权级时钟中断被屏蔽，我们需要在执行第一个应用之前进行一些初始化设置：

```rust
// os/src/main.rs

#[no_mangle]
pub fn rust_main() -> ! {
    clear_bss();
    println!("[kernel] Hello, world!");
    trap::init();
    loader::load_apps();
    trap::enable_timer_interrupt();
    timer::set_next_trigger();
    task::run_first_task();
    panic!("Unreachable in rust_main!");
}

// os/src/trap/mod.rs

use riscv::register::sie;

pub fn enable_timer_interrupt() {
    unsafe { sie::set_stimer(); }
}
```

这样，当一个应用运行了 10ms 之后，一个 S 特权级时钟中断就会被触发。由于应用运行在 U 特权级，且 `sie` 寄存器被正确设置，该中断不会被屏蔽，而是跳转到 S 特权级内的我们的 `trap_handler` 里面进行处理，并顺利切换到下一个应用。

注意，我们并没有将应用初始 Trap 上下文中的 `sstatus` 中的 `SPIE` 位置为 1 。这将意味着 CPU 在用户态执行应用的时候 `sstatus` 的 `SIE` 为 0 ，根据定义来说，此时的 CPU 会屏蔽 S 态所有中断，自然也包括 S 特权级时钟中断。但是可以观察到我们的应用在用尽一个时间片之后能够正常被打断。这是因为当 CPU 在 U 态接收到一个 S 态时钟中断时会被抢占，这时无论 `SIE` 位是否被设置都会进入 Trap 处理流程。



## 3 疑难解决

### 3.1 Multiprog OS

要满足 任务切换 的要求， 所以程序需要预先被加载到一个固定的内存地址， 而不是所有程序共用一个入口地址。 rCore 添加了 user/build.py 读取 user/src/linker.ld 并对每个程序的地址空间进行更改以适应前述要求。

与 Trap 不同， Mult-program OS 中的任务切换发生在内核态 （S Mode） 且不涉及特权级切换， 通过 __switch 函数实现两个不同的 Task Context 的切换。

> 为什么 __switch 需要通过汇编的完成主要功能？
> 由于任务切换不涉及特权级的改变， 因而需要保存的上下文就比较少， 仅需要保存 ra 入口地址， sp 栈指针， 以及 Callee 负责寄存器 s0~s11 即可。 高级程序语言会在函数中自己使用一些通用的寄存器， 可能会发生意料之外的控制流， 另外 __switch 函数仅作为 label 存在不会被 Rust/C 编译器处理， 这些都是使用汇编完成 __switch 主体功能的原因。

### 3.2 Coop OS

> ***丢失的 mv sp, a0***
>
> 可以顺着控制流梳理一遍， 第一次用到 __switch 是初始化时运行 run_first_task 函数。 __switch 将 unused 中的垃圾数据保存在了程序栈后切换到了第一个 task （此后就是内核栈和用户栈之间的切换了）， 通过 ra 指向的 __restore 进行上下文恢复， 对于 task 而并不需要再次更新 sp， 该值已经在 __switch 中被恢复成该任务对应的内核指针了。
>
> 另一个就是进入 trap 之后， __alltrap 最后进入 trap_handler 函数， 该函数最后会在返回参数的 a0 中保存之前存入的 TrapContext， 而在此之前有这么两句指令说明了 sp 就是这个 TrapContext。 因而无需再进行重复保存。
>
> ```c
> mv a0, sp
> call trap_handler
> ```

### 3.3 Timesharing OS

#### RISC-V架构下的中断

在 RISC-V 架构语境下， **中断** (Interrupt) 和 异常（包括程序错误导致或执行 Trap 类指令如 `ecall` ）一样都是一种 Trap ，但是它们被触发的原因却是不同的。

对于某个处理器核而言， 异常与当前 CPU 的指令执行是 **同步** (Synchronous) 的，异常被触发的原因一定能够追溯到某条指令的执行；而中断则 **异步** (Asynchronous) 于当前正在进行的指令，也就是说中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关。

RISC-V 的中断可以分成三类：

>- **软件中断** (Software Interrupt)：由软件控制发出的中断
>- **时钟中断** (Timer Interrupt)：由时钟电路发出的中断
>- **外部中断** (External Interrupt)：由外设发出的中断

另外，相比于异常，中断和特权级之间的联系更为紧密，这三种中断每一个都有 M/S 特权级两个版本。中断的特权级可以决定该中断是否会被屏蔽，以及需要 Trap 到 CPU 的哪个特权级进行处理。

在判断中断是否会被屏蔽的时候，有以下规则：

>- 如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理；
>- 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽。

以内核所在的 S 特权级为例，中断屏蔽相应的 CSR 有 `sstatus` 和 `sie` 。`sstatus` 的 `sie` 为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使 `sstatus.sie` 置 1 ，还要看 `sie` 这个 CSR，它的三个字段 `ssie/stie/seie` 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 `sstatus.sie` 和 `sie.stie` 均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。

如果中断没有被屏蔽，那么接下来就需要软件进行处理，而具体到哪个特权级进行处理与一些中断代理 CSR 的设置有关。默认情况下，所有的中断都需要到 M 特权级处理。而通过软件设置这些中断代理 CSR 之后，就可以到低特权级处理，但是 Trap 到的特权级不能低于中断的特权级。事实上所有的中断/异常默认也都是到 M 特权级处理的。

#### RISC-V中断发生时的硬件行为

默认情况下，当中断产生并进入某个特权级之后，在中断处理的过程中同特权级的中断都会被屏蔽。中断产生后，硬件会完成如下事务：

>- 当中断发生时，`sstatus.sie` 字段会被保存在 `sstatus.spie` 字段中，同时把 `sstatus.sie` 字段置零，这样软件在进行后续的中断处理过程中，所有 S 特权级的中断都会被屏蔽；
>- 当软件执行中断处理完毕后，会执行 `sret` 指令返回到被中断打断的地方继续执行，硬件会把 `sstatus.sie` 字段恢复为 `sstatus.spie` 字段内的值。

也就是说，如果不去手动设置 `sstatus` CSR ，在只考虑 S 特权级中断的情况下，是不会出现 **嵌套中断** (Nested Interrupt) 的。嵌套中断是指在处理一个中断的过程中再一次触发了中断。由于默认情况下，在软件开始响应中断前， 硬件会自动禁用所有同特权级中断，自然也就不会再次触发中断导致嵌套中断了。

#### 时钟中断与计时器

由于软件（特别是操作系统）需要一种计时机制，RISC-V 架构要求处理器要有一个内置时钟，其频率一般低于 CPU 主频。此外，还有一个计数器用来统计处理器自上电以来经过了多少个内置时钟的时钟周期。在 RISC-V 64 架构上，该计数器保存在一个 64 位的 CSR `mtime` 中，我们无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的。

另外一个 64 位的 CSR `mtimecmp` 的作用是：一旦计数器 `mtime` 的值超过了 `mtimecmp`，就会触发一次时钟中断。这使得我们可以方便的通过设置 `mtimecmp` 的值来决定下一次时钟中断何时触发。



## *4 //TODO 实验

